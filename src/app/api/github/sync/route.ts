import { NextRequest, NextResponse } from 'next/server';
import { Octokit } from '@octokit/rest';
import { supabase } from '@/lib/supabase';

interface SyncRequest {
  summaryId: string;
  owner: string;
  repo: string;
  branch?: string;
  token: string;
}

export async function POST(request: NextRequest) {
  try {
    const { summaryId, owner, repo, branch = 'main', token }: SyncRequest = await request.json();

    // Validate required fields
    if (!summaryId || !owner || !repo || !token) {
      return NextResponse.json(
        { error: 'Missing required fields: summaryId, owner, repo, token' },
        { status: 400 }
      );
    }

    // Fetch summary with topics
    const { data: summary, error: summaryError } = await supabase
      .from('summaries')
      .select('*, topics(topic)')
      .eq('id', summaryId)
      .single();

    if (summaryError || !summary) {
      return NextResponse.json(
        { error: 'Summary not found' },
        { status: 404 }
      );
    }

    // Initialize Octokit
    const octokit = new Octokit({ auth: token });

    // Generate markdown content
    const markdown = generateMarkdown(summary);
    
    // Create safe filename from title
    const timestamp = new Date(summary.created_at).toISOString().split('T')[0];
    const safeTitle = summary.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .slice(0, 50);
    const filename = `${timestamp}-${safeTitle}.md`;
    const path = `summaries/${filename}`;

    try {
      // Check if file exists
      let sha: string | undefined;
      try {
        const { data: existingFile } = await octokit.repos.getContent({
          owner,
          repo,
          path,
          ref: branch,
        });
        
        if ('sha' in existingFile) {
          sha = existingFile.sha;
        }
      } catch {
        // File doesn't exist, which is fine
      }

      // Create or update file
      const { data } = await octokit.repos.createOrUpdateFileContents({
        owner,
        repo,
        path,
        message: sha 
          ? `Update summary: ${summary.title}`
          : `Add summary: ${summary.title}`,
        content: Buffer.from(markdown).toString('base64'),
        branch,
        ...(sha && { sha }),
      });

      return NextResponse.json({
        success: true,
        url: data.content?.html_url,
        path,
        message: sha ? 'Summary updated in GitHub' : 'Summary synced to GitHub',
      });
    } catch (error) {
      console.error('GitHub API error:', error);
      
      if (error instanceof Error) {
        if (error.message.includes('Bad credentials')) {
          return NextResponse.json(
            { error: 'Invalid GitHub token. Please check your personal access token.' },
            { status: 401 }
          );
        }
        if (error.message.includes('Not Found')) {
          return NextResponse.json(
            { error: 'Repository not found. Please check the owner and repo name.' },
            { status: 404 }
          );
        }
      }
      
      throw error;
    }
  } catch (error) {
    console.error('Sync error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to sync to GitHub' },
      { status: 500 }
    );
  }
}

function generateMarkdown(summary: {
  title: string;
  video_url: string;
  channel_name?: string;
  duration?: string;
  summary_text: string;
  created_at: string;
  topics?: { topic: string }[];
}): string {
  const date = new Date(summary.created_at).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  let markdown = `# ${summary.title}\n\n`;
  
  markdown += `**Video URL:** ${summary.video_url}\n\n`;
  
  if (summary.channel_name) {
    markdown += `**Channel:** ${summary.channel_name}\n\n`;
  }
  
  if (summary.duration) {
    markdown += `**Duration:** ${summary.duration}\n\n`;
  }
  
  markdown += `**Summarized:** ${date}\n\n`;
  
  if (summary.topics && summary.topics.length > 0) {
    markdown += `**Topics:** ${summary.topics.map(t => t.topic).join(', ')}\n\n`;
  }
  
  markdown += `---\n\n`;
  markdown += summary.summary_text;
  markdown += `\n\n---\n\n`;
  markdown += `*Generated by TubeDigest on ${date}*\n`;

  return markdown;
}
